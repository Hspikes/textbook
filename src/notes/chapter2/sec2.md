# Chapter 2.2 Integer Representations

## Unsigned

编码方式相对简单，直接按位权编码，可以按下面的方式形式化定义函数\\(B_{2}U_{\omega}\\) (Bits to Unsigned)。

\\[B_{2}U_{\omega}(\boldsymbol{x})=\sum_{i=0}^{\omega-1}x_{i}·2^{i}  \\] 

其中 \\(\boldsymbol{x}\\)是编码的位向量，位向量长度为\\(\omega\\)，\\(x_{i}\\)代表位向量第\\(i\\)位。

## Signed: two's-complement encode

相信经过一年半的计算机学习，你已经对编码有过多次了解，那么本文档默认你清楚**原码**，**反码**，**补码**的基础概念，如果在以前的课摆了如今悔过从头再来，又或是有点记不清了，不妨试试 GPT or Deepseek，相信你会得到满意的答案 👍

绝大多数计算机编码有符号数均采用**补码**编码，后文的重点也将落在补码上。部分同学或许觉得反码或者原码这种更为直观简单的编码或许更好理解，但从位运算以及电路的角度上看，补码更为简洁高效，一个最直观的例子就是加法。

本课程和文档不会深入讨论为什么补码优于反码和原码,如果十分感兴趣，或许你在数电课上你会找到答案 🧐

### 补码的基本定义

在听过无数个老师讲过无数次补码以后，个人认为，用位权的方式定义**补码**编码最为清晰，对各种性质的证明也最为自然。课上由于时间原因没能讲到补码自身以及其运算很多性质的证明，本文均会采用位权的方式补充证明，包括位移、加法溢出等等。同样形式定义函数\\(B_{2}T_{\omega}\\) (Bits to Two's)。

\\[B_{2}T_{\omega}(\boldsymbol{x})=-x_{\omega-1}·2^{\omega-1}+\sum_{i=0}^{\omega-2}x_{i}·2^{i}  \\] 

其中符号定义与无符号数中相同，编码的主要差异在于无符号数最高位表示权重为\\(+2^{\omega-1}\\)，而补码编码下有符号位权中为\\(-2^{\omega-1}\\)。

### 反码与原码

1. **反码(One's Complement)**: \\(B_{2}O_{\omega}(\boldsymbol{x})=-(x_{\omega-1}·2^{\omega-1}-1)+\sum_{i=0}^{\omega-2}x_{i}·2^{i}  \\) 

2. **原码(Sign-Magnitude)**: \\(B_{2}S_{\omega}(\boldsymbol{x})=(-1)^{x^{\omega-1}}\sum_{i=0}^{\omega-2}x_{i}·2^{i}  \\) 

原码的定义比较好理解，应该和其他课接触的定义保持一致，其中反码就相对抽象了，我们第一次接触反码时的定义往往是**正数原码按位取反**，非常直观，我们这里简单证明一下两种定义等价。

记任意正数原码真值为 \\(Tval\\)，那么按位取反后除符号位外位权和为 \\(Dval=(2^{\omega-1}-1)-Tval\\)，而考虑符号位权值，则 \\(Tval'=Dval-(2^{\omega-1}-1)=-Tval\\)。两种定义形式等价。

观察反码与补码的位权定义，可以很容易的发现 ```~x+1=-x``` 这一性质，这也是大多数其他课程定义的补码。

进一步思考原码补码，对于一个非负数 \\(x\\) 其位向量表示为 \\(\boldsymbol{x}\\)，我们试图定义 \\(-x\\) 的位形式。

1. 补码定义 \\(1[00...0]_{\omega}-\boldsymbol{x}\\) 为\\(-x\\) 的位向量。

2. 反码定义 \\([11...1]_{\omega}-\boldsymbol{x}\\) 为\\(-x\\) 的位向量。

有了这个理解，在整型运算时你对所谓的**模数系统**的理解也会更深入。

## Mapping Between Signed & Unsigned

### 转换方法

要将有符号数与无符号数相互转化，一种很自然的想法就是：我们不改变位向量，仅仅改变位向量的含义。那既然位向量保持不变，那么对比无符号数以及补码定义的有符号数的位权式，转化就十分显然了。

\\[B_{2}U_{\omega}(\boldsymbol{x})=x_{w-1}·2^{\omega}+B_{2}T_{\omega}(\boldsymbol{x})\\]

### C语言中的转换

```C
int foo = -1;
unsigned bar = 1;
foo < bar == true ?
```

相信上过课的同学对这个小谜题不会太陌生，既然都问你了，答案肯定是反直觉的那个啦~~(某种意义上来讲符合程序员直觉)~~。

C语言中若表达式既包含有符号数又包含无符号数，**C编译器会隐式的全部转换为无符号数再执行运算**。\\(-1\\) 根据刚刚的公式转换为无符号数后应为 \\(2^{32}-1\\)，那么结果自然是```foo > bar```.

------

© 2025. ICS Team. All rights reserved.