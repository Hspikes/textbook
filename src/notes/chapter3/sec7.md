# Chapter 3.7 Procedures

在上一节中我们讨论了条件控制以及循环语句在机器级代码中的翻译，在这一节中我们将会进一步讨论 C 语言中另一个重要的组成部分：**函数**。

无论是**函数**还是说面向对象中的**方法**又或是汇编中的**过程**其实就是一段代码，一个代码块。研究机器级代码中函数调用机制，帮助我们更好的理解**运行栈**，提高我们代码运行效率。

## Mechanisms in Procedures

我们先宏观的来思考一下，函数调用过程应当做些什么。总的来说应该有三个方面:

1. **Passing control**: 我们有先前的积累，已经能够理解代码翻译后机器中只是一条一条指令。那么函数调用时，实际上就是要从一条指令的位置，跳转到另一条指令的位置，并从那里开始执行一系列指令。函数结束时，我们需要返回到调用指令的位置，接着执行调用指令之后的指令。**PC(程序计数器)**指令变更的过程我们需要研究。

2. **Passing data**: 函数调用过程还需要传递一些参数，这些参数该以怎样的形式传递？函数调用结束时需要向调用者返回一些返回值，返回值应当怎样传递？这些数据传递的问题需要讨论。

3. **Memory management**: C 语言中函数中可以定义局部变量，这些局部变量应当怎样分配存储空间？在函数结束时，为了避免空间浪费，我们需要释放这些空间，如何保证空间释放的合理？

接下来几个小节我们将分别深入去研究这些部分。但在开始研究这些问题以前，我们还要提一个重要的概念：**Application Binary Interface(API)**。

从计算机系统的角度，如果不考虑效率便捷性之类的问题，要实现函数调用时参数传递可以有很多方式，我可以存在内存里、存在运行栈里或者保存在特殊的寄存器中，但为了一个统一标准，人们提出了**API**来约束，机器指令的实现都会遵循这个标准，这个标准就是**API**。

甚至对于不同的操作系统会有不同的API，我们接下来讨论的内容都是基于Linux系统的API。如果你在学完这节课后觉得你有更好的想法，欢迎你提出你的API，并说服全世界计算机行业的人放弃以前的标准采取你的标准~~（先不考虑兼容性问题）~~😎

## Stack Structure

要研究函数调用绕不开**运行栈**这个概念，相信大家在初学递归的时候都有过一个经历：因为忘记写递归的退出条件，导致无限递归下去，最后程序被操作系统杀死并告诉你**栈溢出**了。那个时候你一定有疑问：我根本没有到栈这个数据结构，溢出在哪？

这里因为大家应该都学过数据结构与算法这门课，栈这个基础的数据结构就不再过多介绍了，如果你有点记不清了，可以去问问 GPT or Deepseek ：“什么是栈？”

这里所谓的栈溢出实际上就是指运行栈溢出了。所谓的**运行栈是内存中一段特殊的位置**，位于虚拟内存中地址较大的位置。x86-64 中的栈是一个**倒置的栈**，栈顶位于内存很高的一个地址，这个栈的起始地址会是一个随机数~~(你问为什么要随机，这你可能要问一下黑客们了，问问他们干了什么好事)~~然后向下“生长”，每当我向其中存元素时栈就向下延伸。

在前文我们介绍寄存器的时候我们经常提到 **%rsp** 这个寄存器的特殊性，这一节我们终于能讲清楚特殊在哪里。%rsp 始终保存的是**当前栈顶**的位置，也就是一根指针便于我们维护栈。

提到栈离不开两个操作：**入栈(push)**和**出栈(pop)**。由于这两个操作用的太多了，x86指令集将这两个操作单独抽出来做成了两条指令~~（尽管他们都能被其他指令代替）~~。

1. **Push**:```pushq Src```，将```Src```写入当前%rsp指向的内存位置，并将%rsp下移。
2. **Pop**: ```popq Dest```，将%rsp指向内存的位置写入```Dest```中。

有了栈的知识，我们可以开始研究在第一小节中提到的几个问题了。

## Passing Control

我们通过运行栈来帮助我们完成过程的调用与返回

------

© 2025. ICS Team. All rights reserved.