# SSH

现在是5202年，你在无数学长学姐的安利下选择了《计算机系统导论》，并被告知这门课有可能是你在沙坡村学院能够上到的最有用的课。

在被沙坡村学院折磨了许久之后，你像抓住了救命稻草一般，准备再度踏上计算机学习的正轨... :books: :muscle: 

突然，你的手机震动一下，打开一看是助教在ICS课程群里发送了消息：

“...我们为大家准备了服务器，并创建了账号密码，需要使用服务器的同学请SSH到服务器上...”

然而，你没有听说过SSH，也不知道它如何使用，只是盯着自己电脑上的Dev C++发呆，:thinking: :sob:

“算了，先开一把瓦吧”，你对自己说到... :satisfied:

这篇文章，我们将手把手教你如何使用SSH，常见的SSH使用场景，如何编写SSH配置文件...

此外，我们还会介绍SSH的底层工作原理，供对底层感兴趣的同学进行学习 :tada:

当然，笔者不过是比你们多上了两年学的学长/学姐，对于SSH的理解难免出现偏差 :warning: 或错误 :skull_and_crossbones:，欢迎各位同学批评指正 :rose:

## 什么是SSH？

SSH(Secure Shell)是一个**应用层协议**，旨在在不安全的网络上提供安全的远程访问和网络服务。

在SSH出现之前，一般是使用Telnet和FTP等进行远程登陆和文件传输。

然而这些传输方式均采用**明文**进行传输，相当于直接公开自己传输的信息，十分不安全。

SSH使用**加密技术**在两台通信主机之间建立了一个安全的通信信道，因此更加适合现代网络环境。

<img src="./image/ssh-1.png" alt="ssh overview" width="100%" />

```admonish   
**明文**和**密文**是密码学中的两种术语。  
假设两台主机之间需要传递的内容称为信息，则明文指没有任何修饰的（例如加密）原始信息，密文则指使用加密技术进行加密之后的信息。
```

```admonish  
SSH一般指协议标准，而我们日常用的SSH工具一般是OpenSSH，这是SSH协议的开源实现。
```

## SSH的常见使用场景

一般而言，SSH主要有下面几种应用场景：
- 远程登陆
- 安全文件传输
- 端口转发

### SSH登陆远程服务器

SSH远程登陆类似于Windows系统上的远程桌面，不过不同的是，没有桌面环境，只有一个命令行终端。

使用SSH登陆服务器之后，你可以像在本地使用终端一样来操作服务器，这在网络管理和远程开发中十分常见。

由于笔者使用的是物理机Arch Linux，因此下面主要以Linux系统为例介绍命令。

```admonish
本文后续统一将自己本地的主机称为客户端，将远程主机称作服务器。无特殊说明时，客户端和服务器均为Linux系统。
```

#### For Linux

SSH的登陆验证方式主要有**用户密码**验证和**密钥验证**两种

##### 用户密码登陆

用户密码登陆是常见的身份验证方式，一般使用以下的命令格式：

```bash
ssh user@host [-p port]
```

详细解释一下上述命令：
- `ssh`：表示使用`ssh`命令
- `user`：表示需要远程登陆的主机上的用户名，如果用户名和本地用户名相同，则这一部分可以省略
- `host`：表示要登陆的主机名，可以是主机的域名，也可以是主机的IP地址（公网IP或者局域网内私有IP）
- `-p port`：可选，用于指定端口，默认端口为22，如果SSH服务器监听默认端口，则可以省略这一部分

输入上述命令之后，如果没有问题，终端会提示让你输入密码（首次登陆密码一般会告知你，或者按照自己重新设置的密码），

正确输入密码之后，终端上如果输出一堆系统信息，然后打印出远程主机的终端提示符，则说明我们成功登陆了 :tada:

````admonish tip
首次登陆时终端会显示类似这样的一段话（例如ssh首次登陆github）：  
```
The authenticity of host '[ssh.github.com]:443 (<no hostip for proxy command>)' can't be established.  
ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.  
This key is not known by any other names.  
Are you sure you want to continue connecting (yes/no/[fingerprint])?  
```
这段话的目的就是告诉你，客户端知道了这台服务器的公钥的fingerprint，但是无法验证服务器的身份，主要是用于防止中间人攻击。  
你需要输入`yes`，`no`或者`fingerprint`来跳过验证直接连接，拒绝连接或者使用`fingerprint`来验证。  
大部分安全（相信我，没人会攻击你每月几块钱的云服务器的 :blush:）的情况下，可以直接输入`yes`。  
对于公开的服务器，比如Github，官方一般会提供`fingerprint`供用户验证，例如[Github SSH Key fingerprints](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints) 。   
输入fingerprint并按下回车，这时终端会提示：  
```
Please type 'yes', 'no' or the fingerprint:
```
此时输入官方提供的fingerprint，如果验证通过，则终端会提示：  
```
Warning: Permanently added '[ssh.github.com]:443' (ED25519) to the list of known hosts.
```
表示这台服务器通过了认证，并且会永久添加到`known_hosts`，这是`~/.ssh/`目录下的一个文件。  
这个文件中记录了所有通过认证的服务器，当下次连接服务器时，若服务器在`known_hosts`中出现，则会将服务器公钥的fingerprint和这个文件中记录的fingerprint比较，若匹配成功则连接继续，否则会发出警告，提醒你服务器fingerprint改变，需要用户自己确认服务器身份。
````

```admonish tip
fingerprint指公钥的**数字指纹**，由服务器公钥通过特定哈希算法（如SHA256）生成，这样长度比较短小，方便比较。  
对于公开的大型服务器，如Github等，一般会给出自己服务器公钥的fingerprint，用于用户验证服务器身份。  
如果是自己的公网服务器，可以登陆上服务器查看公钥fingerprint，服务器公钥一般位于`/etc/ssh/`目录下，命名为`ssh_host_xxx_key.pub`，xxx是算法类型，比如使用rsa算法生成的公钥文件就是`ssh_host_rsa_key.pub`。  
服务器在第一次安装ssh服务器时会生成这些文件，使用命令`ssh-keygen -lf /etc/ssh/ssh_host_rsa_key.pub`
可以查看公钥的fingerprint。
```

```admonish danger  
用户密码登陆方式存在安全性问题，尽管用户密码会通过加密传输，如果用户设置的密码比较简单（尤其是root用户的密码），很容易被黑客通过暴力破解出来，因此十分建议配置ssh文件，使用密钥进行登陆，这样不仅提高了安全性，每次登陆时也不用输入密码，实现免密登陆。  
如果需要将服务器部署在公网，通过建议在第一次登陆之后就**禁用密码登陆**或者**限制尝试次数**，以及**修改ssh默认端口**等一系列复杂的操作来确保安全。
```

```admonish example
TODO: login EXAMPLE
```

##### 密钥登陆

前面提到，用户密码登陆的方式并不安全，因此更加建议使用密钥进行身份验证。同时，这种方式也无需每次都输入密码，使用起来更加方便。

首先我们需要在本地创建一对公钥和私钥，可以使用下面这条命令进行创建：

```bash
ssh-keygen
```

这条命令默认使用ED25519算法生成长度为256位的密钥对

一些常用可选项：
- `[-t rsa | dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa]`：指定加密算法，不同加密算法复杂性和安全性也不同
- `[-b bits]`指定密钥长度，有些加密算法，如rsa，密钥长度是可以变化的

输入以下命令了解更多：
```bash
ssh-keygen --help
```

输入上述命令之后，不出意外的话，会提示指定密钥存放路径，默认为`～/.ssh/id_rsa`（如果使用rsa算法），若你不想指定其他路径的话，直接按回车即可。

接着会提示你输入密码和确认密码，这个密码是每次使用密钥需要输入的，如果不想设置密码，直接按两次回车即可。

于是我们的ssh密钥对就生成好了 :muscle:

通过`ls`查看`～/.ssh`目录或者你自己指定的存放目录

```bash
ls /your/path/to/ssh/keypair
```

目录下会存在两个文件`keypair.pub`和`keypair`，其中**keypair**是你自己指定的文件名，或者使用特定算法生成的默认名，例如`id_rsa`，带有`pub`后缀的是公钥，不带后缀的是私钥。

```admonish danger
注意私钥一定不要透露给任何人，否则加密就失效了
```

然后我们需要将公钥复制到服务器上，这可以使用以下命令：

```bash
ssh_copy_id [-i /your/path/to/ssh/keypair.pub user@host]
```

上述命令`-i`选项指定公钥文件目录，如果你没有自己指定密钥名，则可以省略这个选项

拷贝成功之后，就可以免密登陆啦 :tada:

```bash
ssh user@host [-i /your/path/to/ssh/keypair]
```

如果你不是默认路径，使用`-i`选项指定路径即可

```admonish example
TODO: login EXAMPLE
```

##### 配置config文件快速登陆

尽管使用公钥登陆的方式免去了密码，但是每次登陆还是需要输入很长一串东西，太繁琐

作为计算机专业的同学，当然是要学会编写各种配置简化使用，下面我们介绍如何配置ssh以更高效的使用

ssh的配置文件位于`~/.ssh/config`，如果没有就创建一个，使用编辑器（推荐`vim/neovim`，毕竟是神之编辑器）打开这个文件，然后输入以下内容（具体内容替换成自己的）

```
Host hostname
    HostName host
    User user
    Port port
    IdentifyFile /your/path/to/ssh/keypair
```

详细解释一下上述的每个字段：
- `Host`：给你自己要连接的服务器随便起个名
- `HostName`：这里host填入实际服务器的域名，或者公网IP，或者局域网内的私有IP
- `User`：填入自己服务器上的用户名
- `Port`：SSH服务器监听的端口，默认为22，如果SSH服务器监听22，可以去掉这一行
- `IdentifyFile`填入自己的私钥文件的地址

全部配置完成之后，输入以下命令：

```bash
ssh hostname
```

即可成功登陆，是不是简单了很多呢

```admonish example
TODO: login EXAMPLE
```

#### For MacOS

#### For Windows

### SCP安全传输文件



## SSH的工作流程和原理

这一部分详细讲解有关SSH协议的工作流程。

```admonish warning
这部分涉及到有关**操作系统**，**计算机网络**，**密码学**等相关知识，如果不熟悉这部分知识理解起来会有难度。  
如果你只是希望了解ssh的有关应用，直接跳过这一节即可。
```

### SSH Overview

SSH协议结构如上如所示，主要分为以下几个部分：
- **传输层协议**： SSH传输层协议主要确保**服务器身份验证**，**数据加密**和**数据完整性**。注意这个传输层协议应该和OSI标准的7层网络协议栈中定义的传输层协议区分开，SSH传输层协议直接运行在TCP/IP协议栈之上，通常基于TCP进行可靠数据传输，默认端口22。
- **用户身份认证协议**： 这个协议用于验证用户身份，最常见的两种方式为**用户密码验证**和**公钥认证**，或是二者结合的方式。
- **连接协议**： 连接协议**多路复用**了单个ssh客户端-服务器组成的ssh通道。换句话说，这个协议创建不同的数据流和多个逻辑通道。

SSH协议基于**客户端-服务器（C/S）**模型，其通常使用TCP协议作为传输层协议，使用TCP时，默认监听22端口。SSH最终使用密钥对用户传输的数据进行**加密传输**，因此实现了在不安全的网络上进行安全传输，SSH从建立连接到数据加密传输的流程大致如上图，主要有以下几个阶段：
- **连接建立**： 客户端首先发起TCP连接，经过三次握手之后，TCP连接成功建立。之后客户端服务器互相协商可用的SSH版本。
- **密钥交换**： 这一部分主要任务是**协商加密算法**（对称/非对称加密，哈希），然后通过**密钥交换算法**生成用于加密信息的会话密钥，这一阶段同时还包含了**服务器端的身份认证**，以防止**中间人攻击**。
- **用户身份认证**： 这一阶段用于验证**客户端身份信息**，也就是前面提到的登陆阶段。
- **信息加密传输**： 这一阶段连接双方的身份信息均已验证，后续的数据传输均采用之前生成的会话密钥进行加密解密。

```admonish
**协议**是计算机网络中的一个重要概念，其规定了通信双方进行数据交换时应该遵守的一组规则。  
**协议栈**则是计算机网络中一系列协议的集合，不同协议位于不同层次，旨在解决不同层次上的问题，低层次的协议为高层次提供服务。  
两大经典协议栈是**OSI模型**和**TCP/IP模型**：  
OSI模型分为了7层，分别是应用层，表示层，会话层，传输层，网络层，数据链路层和物理层。  
TCP/IP模型分为了4层，分别是应用层，传输层，网际层和网络接口层。  
在一般的计算机网络教学中，为了方便，一般分为应用层，传输层，网络层，数据链路层和物理层。  
```

```admonish
TCP协议是**传输层**中的一个重要协议，其为应用层提供了**可靠数据传输服务**，即应用层可以确信TCP会将数据**按序，不丢包**的发送给对端，常用于需要数据可靠传输的应用层协议（如电子邮件，文件传输）中，但时延较高。  
与之相对的是UDP协议，UDP不保证数据可靠传输，因此性能好，常用于需要保证低时延等高性能场景，如流媒体，音视频流等。
```

```admonish
**进程**是操作系统中的一个重要抽象，简单来说，进程可以看作一个**运行中的程序**。以C语言为例，编译系统会将一个或多个C源程序编译链接成一个可执行程序，到目前为止，这个可执行程序仍然驻留在磁盘上，本质上是**静态的一堆机器指令的集合**。当运行这个可执行程序时，加载器在内核中会创建一个进程，将代码正确映射到进程的地址空间中，设置好各个寄存器，最后CPU开始运行，此时**程序从磁盘被加载到了内存**。  
一个进程可以看作一个容器，管理了很多资源，包括寄存器，地址空间以及各种信息，通常叫做**进程上下文**。进程中执行代码的部分可以看作一个执行流，通常叫做**线程**，一个进程可以包括一个或多个线程。  
简单概括，进程更加注重**资源管理**，线程则聚焦于**命令执行**，可以直接被CPU进行调度，因此线程更加轻量。
```

```admonish
**客户端-服务器**模型是主流的通信模型，其余通信模型包括P2P（Peer to Peer）等。客户端和服务器都可以视为运行在主机上的一个进程。其通过网络进行通信，这是一种常见的**进程间通信**方式。在客户端-服务器模型中，客户端作为主动发起连接的一方，而服务器被动
接受来自客户端的连接。
```

```admonish
计算机网络中，用于标记一个主机的身份通常需要**IP地址**和**端口**，更准确的说，IP地址用于识别主机，是网络层中的概念。端口号用于识别主机上运行的不同进程。例如，同一台主机上可能既运行了HTTP服务器，监听80端口，也可能同时运行了ssh服务器，监听22端口，他们共享内核中实现的TCP模块，TCP模块接受一个数据包时，根据端口号将数据包分发给不同的进程。
```

```admonish
密码学中加密方式通常存在**对称加密**，**非对称加密**和**哈希**三种，三种加密方式分别应用于不同的情况。  
  
俄方
```

### 服务器身份认证

在SSH建立连接之后，客户端需要验证服务器的身份，以防止**中间人攻击**。在这个阶段，服务器会将自己的公钥（通常位于`/etc/ssh/`）目录下，发送给客户端，客户端接收公钥并计算其指纹。如果客户端保存了服务器的公钥指纹（在`~/.ssh/known_hosts`文件中存在），则会进行比对，若比对成功则连接继续，否则警告用户指纹不匹配，需要用户自己确认身份。这也就是为什么第一次连接时会发出警告，告诉用户需要自己验证服务器的指纹，因为SSH服务器使用的公钥没办法通过CA进行认证，无法自动确认服务器的真假。

### 算法协商

算法协商阶段，客户端和服务器各自生成自己支持的算法列表，然后双方根据列表选择大家都支持的算法，需要协商的算法包括**对称加密算法**，**非对称加密算法**和**哈希算法**等。SSH协议**混合使用**了各种加密算法，以享受不同加密算法在不同场景下的优势，比如对称加密使用简单快速，因此用于**会话密钥**，而非对称加密使用比较复杂，但安全性高，因此常用于生成会话密钥以及身份验证，而哈希算法通常用于生成短小的指纹或者消息的摘要等。

### 密钥交换

密钥交换指一类算法，其目的是**生成会话密钥**。在SSH中，会话密钥通常使用的是对称加密算法，因此需要保证客户端和服务器双方的会话密钥是一致的，常见的算法有DH，ECDH等。

```admonish example

经典的DH（Diffie-Hellman）密钥交换算法流程如下所示： 
1. 客户端和服务器约定好一个大素数p（几百位）和素数g（g通常比较小，且满足g < p），p和g可以安全公开
2. 客户端选择一个很大的自然数a作为私钥（满足a < p），并计算出客户端的公钥A = (g^a) mod p
3. 服务端选择一个很大的自然数b作为私钥（满足b < p），并计算出服务器的公钥B = (g^b) mod p
4. 双方各自公开并交换自己的公钥A和B
5. 客户端根据自己的私钥a，服务器公钥B和p计算会话密钥S = (B^a) mod p
6. 服务器根据自己的私钥b，客户端公钥A和p计算绘画密钥S = (A^b) mod p

DH算法核心基于**离散对数**，数学上可以证明客户端和服务器计算得到的会话密钥S是相同的。  
DH算法从根本上**移除了会话密钥在网络中传输**的步骤，而保证通信双方得到相同的会话密钥，因此大大提高了安全性。
```

### 用户身份验证

前面提到，用户身份验证阶段通常分为**用户密码登陆**和**密钥登陆**两种，这两种方式的验证机制并不相同，接下来分别解释两种验证方式。

#### 用户密码登陆

使用用户密码方式时，客户端发送登陆请求给服务器，告知服务器使用密码登陆的方式。接着用**会话密钥**将用户名，密码等信息进行加密，服务器端收到加密后的信息之后，用会话密钥进行解密得到用户名和密码，并且与本地存储的用户名密码信息比对，若匹配成功则向客户端报告登陆成功，否则客户端继续尝试登陆。

#### 密钥验证

使用密钥验证时，客户端发送登陆请求给服务器，告知服务器使用密钥验证的方式，并且会附上密钥对的ID。服务器受到信息后，查找本地保存客户端密钥的文件（通常是`~/.ssh/authorized_keys`），根据客户端发来的密钥对ID进行查找，如果发现了对应的客户端公钥，则服务器随机生成一段字符串，使用**客户端公钥**进行加密，并发送给客户端，客户端收到信息后，使用自己的私钥进行解密，解密之后得到相应的字符串，接着使用哈希算法（一般是md5算法）通过这个字符串生成摘要，并发送给服务器。服务器收到客户端的摘要之后，自己也使用相同的哈希算法应用于生成的随机字符串，和客户端的摘要进行比较，若比较通过，则验证成功。否则客户端登陆失败并重试。


## 其他SSH使用场景

### vscode使用SSH进行远程开发

### github使用SSH

### 使用SSH连接自己的虚拟机

------

© 2025. ICS Team. All rights reserved.
